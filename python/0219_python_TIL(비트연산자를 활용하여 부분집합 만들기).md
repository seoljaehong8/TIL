# 비트연산자를 활용하여 부분집합 만들기

> n이 어떤 집합의 원소 갯수라고 하자.
>
> - 특정 부분집합에 대한 특정 원소의 포함여부는 각 원소마다 2가지 경우를 가진다.(들어간다 or 들어가지 않는다)
> - 이를 원소의 갯수만큼 반복하여 생각하면, 모든 부분집합의 경우를 알 수 있다.
>
> - 리스트의 원소 개수가 총 5개일때 부분집합의 갯수는 2의 5승만큼 존재한다고 할 수 있다.
>
> - 우선 부분집합의 개수를 비트형태로 생각해보면 `00000~11111`의 숫자로 대변할 수 있는 부분집합들을 가질 수 있다.(2의 5승 개)
> - 부분집합에는 공집합이 포함되므로 확인해야 할 갯수는 2^5 - 1

```python
arr = [1,2,3,4,5]
n = len(arr)
 
for i in range(1<<n): 
    for j in range(n): 
        if i & (1<<j):
            print(arr[j], end='')
    print()
```

> `for i in range(1<<n)` 
>
> - 00000~11111의 경우를 모두 확인해야 한다.
>
> `for j in range(n)`
>
> - 원소는 n개(5개)만큼 존재하므로, 각 인덱스마다 해당 원소가 이번 부분집합에 들어갈지 말지를 확인한다.
>
> `if i & (1<<j)`
>
> - 처음반복문을 돌렸던 00000~11111 의 수가 활용된다.
> - &: and연산(둘다 1일때 1)
>   - ex) a = 3(0011) , b=5(0101) ==> a&b = 1(0001)
> - j에는 0,1,2,3,4가 들어가고 if문의 (1<<j)는 2^0(1), 2^1(2), 2^2(4), 2^3(8), 2^4(16)가 들어간다. (00001, 00010, 00100, 01000,10000)

